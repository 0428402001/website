<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<title>ZMap · Documentation</title>
		<meta name="description" context="some description should go here"/>
		
		<link href="css/bootstrap.min.css" rel="stylesheet"/>
		<link href="css/bootstrap-responsive.min.css" rel="stylesheet"/>
		<link href="css/local.css" rel="stylesheet"/>
	</head>
	<body>
		<script type="text/JavaScript" src="js/jquery.min.js"></script> 
		<script type="text/JavaScript" src="js/bootstrap.min.js"></script> 
		<div class="navbar navbar-static-top navbar-inverse">
		  <div class="navbar-inner">
		    <a class="brand" href="index.html">ZMap · The Ultrafast Internet Scanner</a>
		    <ul class="nav pull-right">
		      <li><a href="introduction.html">Introduction</a></li>
					<li class="active"><a href="documentation.html">Documentation</a></li>
					<li><a href="download.html">Download</a></li>
		    </ul>
		  </div>
		</div>
		<div class="content">
			<div class="container">
				<div class="row-fluid">
					<div class="span12 white-panel title">
						<div class="titlecontent">
							<h2>ZMap · Technical Documentation</h2>
						</div>
					</div>
				</div>
				<div class="row-fluid">
					<div class="span2">
						<ul class="white-nav nav nav-tabs nav-stacked">
							<li><a href="#basic">Basic Usage</a></li>
							<li><a href="#output">Results Output</a></li>
							<li><a href="#address">Scan Order</a></li>
							<li><a href="#blacklisting">Blacklisting</a></li>
							<li><a href="#ratelimiting">Rate Limiting</a></li>
							<li><a href="#ratelimiting">Sampling</a></li>
							<li><a href="#multiple">Multiple Packets</a></li>
							<li><a href="#advanced">Advanced Usage</a></li>
							<li><a href="#extension">Extending ZMap</a></li>
						</ul>
						</div>
					<div class="span10 white-panel">
						<div class="content">
							<a name="basic"></a> 
							<h3>Basic Usage</h3>
							<p>ZMap currently supports two types of scanning: TCP SYN scanning against a single target port and ICMP echo request (ping) scanning. For all types of scans, ZMap requires several parameters: source ip address and gateway MAC address. ZMap supports sending packets from multiple source IP addresses and in the case of TCP SYN scans, from multiple ports. Because ZMap utilizes a raw socket to send network packets and <b>libpcap</b> to collect responses, ZMap must be run as root or with <b>cap_net_raw</b> (recommended). In the case that you want packets sent through a non-default interface, this can be be set by providing the <strong>interface</strong> argument.</p> <p> Basic arguments:</p>
							
							<dl class="dl-horizontal params">
								<dt>-S, --source-ip=ip|range</dt><dd>Source address(es) for scan packets (e.g. <b>1.1.1.3-1.1.1.8</b>)</dd>
							  	<dt>-G, --gateway-mac=addr</dt><dd>Specify gateway MAC address (e.g. <b>b4:23:f9:28:fa:2d</b>)</dd>
								<dt>-I, --interface=name</dt><dd>Specify network interface to use (e.g. <b>eth1</b>)</dd>
							</dl>
							
							<p><span class="label label-info">Heads Up!</span> One of the reasons that ZMap supports sending packets from multiple addresses and source ports is because this allows the scanner to embed small amounts of packet checksum data in these fields. This functionality helps the scanner separate legitimate responses from extraneous responses that may be received during scan runtime. If you scan from a single source port and single source address, ZMap has no ability of filtering out these extraneous responses.</p>	
																
							<br/><h4>TCP SYN Scans</h4>
							<p>When performing a TCP SYN scan, ZMap requires a single target port and supports specifying a range of source ports from which the scan will originate.</p>
							<dl class="dl-horizontal params">
								<dt>-t, --target-port=port</dt><dd>TCP port number to scan (e.g. <b>443</b>)</dd>
								<dt>-P, --source-port=port|range</dt><dd>Source port(s) for scan packets (e.g. <strong>40000-50000</strong>)</dd>
							</dl>
							<p>For example, if you wanted to scan the Internet on port 443, from interface <b>eth1</b> at the rate of 1,000,000 hosts per second and saving the IP addresses that responded with synack packets, this could be accomplished with a command similar to the following:</p>
							<pre>zmap -t 443 -G 'b4:23:f9:28:fa:2d' -I eth1 -S 1.1.1.4 -r 10000000 -o results.csv</pre><br/>

							<p><span class="label label-warning">Warning!</span> ZMap relies on the Linux kernel to respond to SYN/ACK packets with RST packets in order to close connections opened by the scanner. This occurs because ZMap sends packets at the ethernet layer in order to reduce overhead otherwise incurred in the kernel from tracking open TCP connections and performing route lookups. As such, if you have a firewall rule that tracks established connections such as a netfilter rule similar to <code>-A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT</code>, this will block SYN/ACK packets from reaching the kernel. This will not prevent ZMap from recording responses, but it will prevent RST packets from being sent back, ultimately using up a connection on the scanned host until your connection times out. We strongly recommend that you select a set of unused ports on your scanning host which can be allowed access in your firewall and specifying this port range when executing ZMap, similar to the following:</p>
							<pre>zmap -t 443 -G 'b4:23:f9:28:fa:2d' -I eth1 -S 1.1.1.4 -r 10000000 -P '50000-60000'</pre>
							<br/>
							
							<h4>ICMP Echo Request Scans</h4>
							<p>While ZMap performs TCP SYN scans by default, it also supports ICMP echo request scans in which an ICMP echo request packet is sent to each host and the type of ICMP response received in reply is denoted. An ICMP scan can be performed by selecting the <strong>icmp_echoscan</strong> scan module similar to the following:</p>
							<pre>zmap -t 443 -G 'b4:23:f9:28:fa:2d' -S 1.1.1.4 --scan-type=icmp_echoscan -r 10000000</pre>
							<br/>
							<h4>Configuration Files</h4>
							<p>ZMap supports configuration files instead of requiring all options to be specified on the command-line. A configuration can be created by specifying one long-name option and the value per line such as:</p>
							<pre>
interface "eth1"
source-ip 1.1.1.4-1.1.1.8
gateway-mac b4:23:f9:28:fa:2d # upstream gateway
cooldown-time 300 # seconds
quiet
summary
</pre><br/>
<p>ZMap can then be run with a configuration file and specifying any additional necessary parameters:</p>
<pre>zmap --config=~/.zmap.conf --target-port=443 </pre>
							<br/>
							<h4>Verbosity</h4>
							<p>There are several types of on-screen output that ZMap produces. By default, ZMap will print out basic progress information similar to the following every 1 second. This can be disabled by setting the <strong>quiet</strong> flag.</p>
							<pre>
send: 74983 74949 p/s (74917 p/s avg); recv: 2150 2150 p/s (2148 p/s avg); hits: 0.29%</pre>
<br/>
<p>ZMap also prints out informational messages during scanner configuration such as the followingwhich can be controlled with the <strong>verbosity</strong> argument.</p>
<pre>
Jan 29 00:46:17.116 [INFO] blacklist: '0.0.0.0/8'
Jan 29 00:46:17.116 [INFO] blacklist: '10.0.0.0/8'
Jan 29 00:46:17.116 [INFO] blacklist: '192.168.0.0/16'
</pre>
<br/>
<p>ZMap also supports printing out a grep-able summary at the end of the scan, similar to below, which can be invoked with the <strong>summary</strong> flag.</p>
<pre>
cnf	target-port				443
cnf	source-port-range-begin			32768
cnf	source-port-range-end			61000
cnf	source-addr-range-begin			1.1.1.4
cnf	source-addr-range-end			1.1.1.8
cnf	maximum-packets				4294967295
cnf	maximum-runtime				0
cnf	permutation-seed			0
cnf	cooldown-period				300
cnf	send-interface				eth1
cnf	rate					45000
env	nprocessors				16
exc	send-start-time				Fri Jan 18 01:47:35 2013
exc	send-end-time				Sat Jan 19 00:47:07 2013
exc	recv-start-time				Fri Jan 18 01:47:35 2013
exc	recv-end-time				Sat Jan 19 00:52:07 2013
exc	sent					3722335150
exc	blacklisted				572632145
exc	first-scanned				1318129262
exc	hit-rate				0.874102
exc	synack-received-unique			32537000
exc	synack-received-total			36689941
exc	synack-cooldown-received-unique		193
exc	synack-cooldown-received-total		1543
exc	rst-received-unique			141901021
exc	rst-received-total			166779002
adv	source-port-secret			37952
adv	permutation-gen				4215763218
</pre>
<br/>
<p>Verbosity Arguments:</p>
<dl class="dl-horizontal params">
	<dt>-q, --quiet</dt><dd>Do not print update regular status updates</dd>
	<dt>-g, --summary</dt><dd>Provide a greppable summary at the end of the scan</dd>
	<dt>-v, --verbosity=n</dt><dd>Level of output detail</dd>
	<dt>-h, --help</dt><dd>Print help and exit</dd>
	<dt>-V, --version</dt><dd>Print version and exit</dd>
</dl>
<br/>
							<h4>Dry-Run Mode</h4>
							<p>Dry-run mode allows you test your configuration and find what packets will be sent without creating any traffic.</p> <dl class="dl-horizontal params">
								<dt>-d, --dryrun</dt><dd>Don't send actual packets</dd>
							</dl>
							
							<p>Instead of sending any traffic, ZMap will produce an output similar to the following:</p>
											
<pre>tcp { source: 46870 | dest: 443 | seq: 15587922 | checksum: 2520973312 }
ip { saddr: 1.1.1.4 | daddr: 98.28.28.36 | checksum: 910295040 }
eth { shost: 00:8b:24:d4:5b:f3 | dhost: b4:23:f9:28:fa:2d }
---------------------------------------------------------------------------------
tcp { source: 52413 | dest: 443 | seq: 15587922 | checksum: 1787953152 }
ip { saddr: 1.1.1.4 | daddr: 114.144.33.186 | checksum: 540540928 }
eth { shost: 00:8b:24:d4:5b:f3 | dhost: b4:23:f9:28:fa:2d }
---------------------------------------------------------------------------------
tcp { source: 38524 | dest: 443 | seq: 15587922 | checksum: 3076063232 }
ip { saddr: 1.1.1.4 | daddr: 177.175.204.20 | checksum: 918421504 }
eth { shost: 00:8b:24:d4:5b:f3 | dhost: b4:23:f9:28:fa:2d }</pre><br/>

							<a name="output"></a> 
							<h3>Results Output</h3>
								<p>ZMap can produce results in several formats through the use of output modules. ZMap currently supports three output formats: <strong>simple-file</strong>, <strong>extended-file</strong>, and <strong>redis</strong>. By default, ZMap will return results in the simple-file format and if no output file is specified, ZMap will not produce specific results. See <a href="#extension">Extending ZMap</a> for informationals.</p>
								
								<dl class="dl-horizontal params">
									<dt>-o, --output-file=p</dt><dd>File to write list of live IPs to</dd>
								  <dt>-M, --output-module=p</dt><dd>Invoke a custom output module</dd>
									<dt>-L, --list-output-modules</dt><dd>Lists installed output modules</dd>
								</dl><br/>
								
								<h4>Simple File</h4>
								<p>The simple file module will produce an output file containing only the unique IP addresses that responded successfully (e.g. SYNACK packet for TCP SYN scan). Example:
<pre>115.237.116.119
23.9.117.80
207.118.204.141
217.120.143.111
50.195.22.82
31.6.64.244
145.216.89.22
68.171.59.173</pre>						<br/>
								<h4>Extended File</h4>
								<p>The extended file module will produce a detailed record of all responses received from the scan:</p>
<pre>type,	saddr,		daddr,	 sport, dport, cooldown, rpt,	timestamp
synack,	12.32.45.67,	1.1.1.3, 443,	55834, 0,	 0, 	2013-01-25 14:58:43.833
rst,	119.220.213.46,	1.1.1.2, 443,	38424, 0,	 0,	2013-01-25 14:58:43.845
rst, 	119.220.213.46,	1.1.1.2, 443,	38424, 0,	 1,	2013-01-25 14:58:43.849
rst, 	189.64.129.255,	1.1.1.3, 443,	39083, 0,	 1,	2013-01-25 14:58:49.381
synack,	117.197.21.208,	1.1.1.2, 443,	44826, 0,	 1,	2013-01-25 14:58:49.381
rst, 	209.145.67.159,	1.1.1.3, 443,	56190, 0,	 1,	2013-01-25 14:58:49.386
rst, 	14.234.179.115,	1.1.1.3, 443, 	50203, 0,	 1,	2013-01-25 14:58:49.386</pre><br/>
								<h4>Redis</h4>
<p>The redis output module allows addresses to be added to a Redis queue instead of being saved to file which ultimately allows ZMap to be incorporated with post processing tools.</p
  
  <p> <span class="label label-info">Heads Up!</span> ZMap does not build with Redis support by default. If you are building ZMap from source, you can build with Redis support by running <code>make REDIS=true</code>.</p>
														<br/>

							<a name="address"></a> 
							<h3>Scan Order and Address Selection</h3>
							
							<p>IP addresses are scanned in a random permutation that is generated at the beginning of each scan. If you want to scan addresses in the same order over multiple scans or to scan the same subset of the IPv4 address space (see <a href="#sampling">sampling</a>), you can specify the permutation by specifying the seed option. It is not possible to specify the exact order in which addresses are scanned.</p>

							<dl class="dl-horizontal params">
							  <dt>-s, --seed=n</dt><dd>Set seed for selecting address permutation</dd>
							</dl>
							<br/>
							<a name="blacklisting"></a> 
							<h3>Blacklisting and Whitelisting</h3>
							<p>ZMap supports both blacklisting and whitelisting network prefixes. If ZMap is not provided with blacklist or whitelist parameters, ZMap will scan all IPv4 address (including local, reserved, and multicast addresses). If a blacklist file is specified, network prefixes in the blacklisted segments will not be scanned; if a whitelist file is provided, only network prefixes in the whitelist file will be scanned. A whitelist and blacklist file can be used in coordination. Whitelist and blacklist files can be specified on the command-line as follows:</p>

<dl class="dl-horizontal params">
  <dt>-b, --blacklist-file=path</dt><dd>File of subnets to blacklist in CIDR notation, e.g. 192.168.0.0/16</dd>
	<dt>-w, --whitelist-file=path</dt><dd>File of subnets to limit scan to in CIDR notation, e.g. 192.168.0.0/16</dd>
</dl>
	
<p>Blacklist files should be formatted with a single network prefix in <a href="http://en.wikipedia.org/wiki/CIDR_notation">CIDR notation</a> per line. Comments are allowed using the <code>#</code> character. Example:</p>
						
<pre>
0.0.0.0/8           # reserved
10.0.0.0/8          # RFC 1918
192.168.0.0/16      # RFC 1918
172.16.0.0/12       # RFC 1918
224.0.0.0/3         # multicast/future use
169.254.0.0/16      # link local addresses</pre><br/>
							<p><span class="label label-info">Heads Up!</span> If you are looking to scan only a random portion of the internet, checkout <a href="#sampling">Sampling</a>, instead of using whitelisting and blacklisting.</p>	
							<br/>

							<a name="ratelimiting"></a> 
							<h3>Rate Limiting and Sampling</h3>
							<p>By default, ZMap will scan at the fastest rate that your network adaptor supports. In our experiences on commodity hardware, this is generally around 95-98% of the theoretical speed of gigabit ethernet, which may be faster than your upstream provider can handle. ZMap will not automatically adjust its send-rate based on your upstream provider and the send-rate may need to be manually adjusted to find the fastest you can scan without experiencing significant packet drop.</p>
							<dl class="dl-horizontal params">
								<dt>-r, --rate=pps</dt><dd>Set maximum send rate in packets/sec</dd>
							</dl>

							<p>ZMap also allows random sampling of the IPv4 address space by specifying max-targets and/or max-runtime. Because hosts are scanned in a random permutation generated per scan instantiation, limiting a scan to <emph>n</emph> hosts will perform a random sampling of <emph>n</emph> hosts. Command-line options:</p>
							<dl class="dl-horizontal params">
							  <dt>-m, --max-targets=n</dt><dd>Cap number of targets to probe</dd>
							  <dt>-T, --max-runtime=s</dt><dd>Cap length of time for sending packets (in seconds)</dd>
							</dl>
							<p>For example, if you wanted to scan the same one million hosts on the Internet for multiple scans, you could set a predetermined seed and cap the number of scanned hosts similar to the following:</p>
							<pre>zmap -t 443 -G 'b4:23:f9:28:fa:2d' -I eth1 -S 1.1.1.4 -s 3 -m 10000000 -o results.csv</pre><br/>
							<p>In order to determine which one million hosts were going to be scanned, you could run the scan in dry-run mode which will print out the packets that would be sent instead of performing the actual scan.</p>
							<pre>zmap -t 443 -G 'b4:23:f9:28:fa:2d' -I eth1 -S 1.1.1.4 -s 3 -m 10000000 --dryrun</pre>
							<br/>
							<a name="multiple"></a> 
							<h3>Sending Multiple Packets</h3>
							<p>ZMap supports sending multiple packets to each host through two options <strong>packet-streams</strong> and <strong>ident-packets</strong>. When multiple packet streams are used, slightly different packets (differing in source address or source port) are sent to each host and if a host receives these multiple packets, it will open a connection for each packet. In the case of identical packets, the a distinct packet will be sent multiple times to the same host. If a host received multiple identical packets, these often be treated as duplicates and only a single connection will be opened.</p>
			
							<dl class="dl-horizontal params">
							  <dt>-u, --packet-streams=n</dt><dd>The number of unique packets sent to an IP address</dd>
							  <dt>-p, --ident-packets=n</dt><dd>The number of times each particular scan packet is sent</dd>
							</dl>
							<br/>
							
							<p><span class="label label-info">Heads Up!</span> Many routers on the Internet drop duplicated packets (such as those created by the <strong>ident-packets</strong>).</p>	
												<br/>	
							<a name="advanced"></a> 
							<h3>Advanced Options</h3>
							<h4>Scanner Cool-Down</h4>
							<p> Because the sending and receiving components of ZMap operate independently, each can run for different lengths of time. We generally recommend that receiving component continue running approximately 30 seconds after the finish of the sending thread in order to receive any slow responses. This can be set to a different value via the <strong>cooldown-time</strong> parameter</p>
							<dl class="dl-horizontal params">
								<dt>-c, --cooldown-time=secs</dt><dd>How long to wait after the last packet is sent before terminating receiver</dd>
							</dl>
							<br/>
							<h4>Threading</h4>
							<p>ZMap always operates the sending and receiving components in separate threads. However, ZMap also supports sending from multiple threads which can greatly improve performance. The <strong>sender-threads</strong> parameter determines the number of threads that ZMap will utilize to send packets. It generally does not increase performance to have a larger number than sending threads than the number of available CPUs in the scanning host.</p>
							<dl class="dl-horizontal params">
								<dt>-n, --sender-threads</dt><dd>Threads used to send packets (default=`1')</dd>
							</dl><br/>
							<a name="extension"></a> 
							<h3>Extending ZMap</h3>
							<p>ZMap can be extended to support different types of scanning through <strong>send modules</strong> and additional types of results output through <strong>output modules</strong>. Registered send and output modules can be listed through the command-line interface:</p>
							<dl class="dl-horizontal params">
								<dt>-L, --list-output-modules</dt><dd>Lists installed output modules</dd>
								<dt>-l, --list-scan-types</dt><dd>Lists available scan types</dd>
							</dl><br/>
							<h4>Output Modules</h4>
							<p>ZMap output and post-processing can be extended by implementing and registering <strong>output modules</strong> with the scanner. Output modules receive a callback for every received response packet. While the default provided modules provide simple output, these modules are also capable of performing additional post-processing (e.g. keeping track of duplicates or outputting numbers in terms of AS instead of IP address)</p><br/>
							
<p>Output modules are created by defining a new output_module struct and registering it in <a href="#">output_modules.c</a>:</p>

<pre>struct output_module {
	
    const char *name; <em>// how is output module referenced in the CLI</em>
    unsigned update_interval; <em>// how often is update called in seconds</em>

    setup_cb init;  <em>// called at scanner initialization</em>
    update_cb start; <em>// called at the beginning of scanner</em>
    update_cb update; <em>// called every update_interval seconds</em>
    update_cb close; <em>// called at scanner termination</em>

    send_cb synsend; <em>// called when a probe packet is sent</em>
    pckt_cb success_ip; <em>// called when a successful response is received</em>
    pckt_cb other_ip; <em>// called when any other responses are received</em>
	
} output_module_t;</pre><br/>
	
<p>Output modules must have a name which is how they are referenced on the command-line and generally implement <code>success_ip</code> and oftentimes <code>other_ip</code> callback. The success_ip callback is called for every response packet that is received and is classified as a success (e.g. TCP SYN/ACK or ICMP echo response) by the current <strong>send module</strong>. The <code>other_ip</code> callback is called whenever a non-successful, but valid response (e.g. TCP RST or ICMP route unreachable) is received. These callbacks must define functions that match the <code>pckt_cb</code> definition:</p>

<pre>
int (*pckt_cb) (

    ipaddr_n_t saddr, <em>// IP address of scanned host in network-order</em>
    ipaddr_n_t daddr, <em>// destination IP address in network-order </em>

    port_n_t sport, <em>// port of scanned host in network-order</em>
    port_n_t dport, <em>// destination port in network-order</em>

    struct timeval* recv_at, <em>// timeval of when response was received</em>
    const char* response_type, <em>// send-module classification of packet</em>

    int is_repeat, <em>// {0: first response from host, 1: subsequent responses}</em>
    int in_cooldown, <em>// {0: not in cooldown state, 1: scanner in cooldown state}</em>

    const u_char* packet, <em>// pointer to raw packet struct</em>
    size_t packet_len <em>// length of raw packet</em>
    
);
</pre><br/>
	
<p>An output module can also register callbacks to be executed at scanner initialization (tasks such as opening an output file), start of the scan (such as documenting blacklisted addresses), during regular intervals during the scan (tasks such as progress updates), and close (tasks such as closing any open file descriptors). These callbacks are provided with complete access to the scan configuration and current state:</p>
<pre>int (*update_cb)(struct state_conf*, struct state_send*, struct state_recv*);</pre>
<p>which are defined in <a href="#">state.h</a>. An example is available at <a href="#">src/output_modules/module_extended_file.c</a>.</p>
<br/>

							<h4>Send Modules</h4>
<p>Packets are constructed using <strong>send modules</strong> which allow abstracted packet creation and response classification. Each type of scan (e.g. TCP SYN scan or ICMP echo request scan) is implemented by developing and registering the necessary callbacks in a <code>send_module_t</code> struct:</p>
<pre>
struct send_module {
  const char *name; <em>// how scan is invoked on command-line</em>

  size_t packet_length; <em>// how long is probe packet (must be static size)</em>
  const char *pcap_filter; <em>// PCAP filter for collecting responses</em>

  setup_cb global_initialize; <em>// called once at scanner initialization</em>
  send_init_cb thread_initialize; <em>// called once for each thread packet buffer</em>
  make_packet_cb make_packet; <em>// called once per host to update packet</em>
  
  print_packet_cb print_packet; <em>// called per packet if in dry-run mode</em>
  classify_packet_cb classify_packet; <em>// called by receiver to classify response</em>
  update_cb close; <em>// called at scanner termination</em>
  
  response_type_t responses[]; <em>// possible response classifications</em>

} send_module_t;
</pre><br/>
<p>and a set of responses as which packets can be classified. Example:</p>
<pre>
static response_type_t responses[] = {
	{
		.is_success = 1,	
		.name = "synack"
	},
	{
		.is_success = 0,
		.name = "rst"
	}
};</pre>
<br/><p>At scanner initialization, <code>global_initialize</code> is called once and can be utilized to perform any necessary global configuration or initialization. However, <code>global_initialize</code> does not have access to the packet buffer which is thread-specific. Instead, <code>thread_initialize</code> is called at the initialization of each sender thread and is provided with access to the buffer that will be used for constructing probe packets along with global source and destination values. This callback should be used to construct the host agonistic packet structure such that only specific values (e.g. destination host and checksum) need to be be updated for each host. For example, the ethernet header will not change between headers (minus checksum which is calculated in hardware by the NIC) and therefore can be defined ahead of time in order to reduce overhead at scan time.</p>

<p>The <code>make_packet</code> callback is called for each host that is scanned to allow the <strong>scan module</strong> to update host specific values and is provided with port and IP address values. The send module must utilize these values instead of assigning their own or response packets will be discarded.</p>
<pre>int make_packet(
  
  void *buf, // packet buffer
  
  ipaddr_n_t src_ip, // source IP in network-order
  port_n_t src_port, // source port in network-order
  
  ipaddr_n_t dst_ip, // destination IP in network-order
  port_n_t dst_port // destination IP in network-order

);</pre><br/>

<p>Scan modules must also define <code>pcap_filter</code> and <code>classify_packet</code>. Only packets that match the PCAP filter will be considered by the scanner. For example, in the case of a TCP SYN scan, we only want to investigate TCP SYN/ACK or TCP RST packets and would utilize a filter similar to <code>tcp && tcp[13] & 4 != 0 || tcp[13] == 18</code>. The <code>classify_packet</code> function
  
  
</p>
							
					</div>
				</div>
			</div>
			</div>
		</div>
	</body>
</html>