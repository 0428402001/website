<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<title>ZMap · Documentation</title>
		<meta name="description" context="some description should go here"/>
		
		<link href="css/bootstrap.min.css" rel="stylesheet"/>
		<link href="css/bootstrap-responsive.min.css" rel="stylesheet"/>
		<link href="css/local.css" rel="stylesheet"/>
	</head>
	<body>
		<script type="text/JavaScript" src="js/jquery.min.js"></script> 
		<script type="text/JavaScript" src="js/bootstrap.min.js"></script> 
		<div class="navbar navbar-static-top navbar-inverse">
		  <div class="navbar-inner">
		    <a class="brand" href="index.html">ZMap · The Internet Scanner</a>
		    <ul class="nav pull-right">
					<li><a href="paper.html">Research Paper</a></li>
		      <li class="active"><a href="documentation.html">Documentation</a></li>
					<li><a href="download.html">Download</a></li>
		    </ul>
		  </div>
		</div>
				<div class="row-fluid"> 
					<div class="span10 white-panel offset1 title">
						<div class="content">
						  <h3>ZMap Documentation</h3>
						  <div class="container">
						    <div class="row-fluid"> 
						      <div class="span4 offset1">
						        <p class="front"><b>1. <a href="#gettingstarted">Getting Started with ZMap</a></b></p>
						        <p class="front"><b>2. <a href="#bestpractices">Scanning Best Practices</a></b></p>
      							<p class="section"><b>3. <a href="#extendingzmap">Extending ZMap and Applications</a></b></p>
      							<ol class="subsection">
      							  <li><a href="writingmodules">Writing Probe and Output Modules</a></li>
      							  <li><a href="#sampleapps">Included Sample ZMap Applications</a></li>
      							  </ol>
						      </div>
						      <div class="span5">
						        
      							<p class="section"><b>4. <a href="">Command Line Documentation</a></b></p>
      							<ol class="subsection">
      							  <li><a href="">Basic Scan Configuration</a></li>
      								<li><a href="">Sampling and Rate Limiting</a></li>
      								<li><a href="">Scan Order and Address Selection</a></li>
      								<li><a href="">Blacklisting and Whitelisting</a></li>
      							  <li><a href="">Advanced Options</a></li>
      							  </ol>

						      </div>
						    </div>
						  </div>


						</div>
					</div>
				</div>
				</div>
				<div class="row-fluid"> 
					<div class="span10 white-panel offset1 nontitle">
						<div class="content">
						  <h3>Getting Started with ZMap</h3>
              <p class="front">This section describes how to start using ZMap for the first time. If you have not already downloaded Zmap, we recommend installing the <a href="download.html">latest stable version</a>. Before performing any scans, we strongly encourage researchers to contact their local network administrators. By default, ZMap will utilize all available bandwidth at its disposal, which can inadvertently cause service disruptions for other users on your local network. We have also provided a list of <a href="#bestpractices">best practices</a> for researchers.</p>
                
                <p class="front">Out of the box, ZMap supports TCP SYN scanning against a single target port and ICMP echo request (ping) scanning. Unless specified otherwise, ZMap will perform a TCP SYN scan against the specified port at the maximum rate possible using the default network interface and gateway. A more conservative configuration that will scan 10,000 random addresses on port 80 at a maximum 10 Mbps can be run as follows:</p>
                <div class="indent"><pre><b>$ zmap --bandwidth=10M --target-port=80 --max-targets=10000 --output-file=results.txt </b></pre></div>
                <p class="front">If the scan started successfully, you will see status statements similar to the following:</p>
                <div class="indent"><pre>0:01 0%; send: 10046 10.0 Kp/s (8.57 Kp/s avg); recv:  87 86 p/s (74 p/s avg); hits: 0.87%
0:02 0%; send: 20046 10.0 Kp/s (9.23 Kp/s avg); recv: 174 86 p/s (80 p/s avg); hits: 0.87%
0:03 0%; send: 30047 10.0 Kp/s (9.47 Kp/s avg); recv: 255 80 p/s (80 p/s avg); hits: 0.85%
0:04 0%; send: 40047 10.0 Kp/s (9.60 Kp/s avg); recv: 344 88 p/s (82 p/s avg); hits: 0.86%</pre></div>
                <p class="front">If you do not know the scan rate that your network can support, you may want to experiment with different scan rates or bandwidth limits to find the fastest rate that your network can support before you see decreased results. ZMap will output the list of distinct IP addresses that responded with a SYN ACK on port 80 as they are found, similar to the following. There are several additional formats for <a href="#">outputting results</a> as well as options for producing <a href="#">programmatically parseable scan statistics</a>.</p>
                <div class="indent"><pre>115.237.116.119
23.9.117.80
207.118.204.141
217.120.143.111
50.195.22.82
</pre></div>
     <p class="front">In the previous examples, we did not specify any network related options. By default, ZMap will attempt to determine your server's default interface and route. If you are performing scans using a dedicated network interface or if ZMap cannot determine your default interface, it can be specified with <code>-i</code> or <code>--interface</code>. Similarly, source IP address(s) can be specified by supplying <code>-s</code> or <code>--source-ip</code> and the MAC address of your gateway can be specified with <code>-G</code> or <code>--gateway-mac</code>. Example: </p>
     <div class="indent"><pre><b>$ zmap -B 10M -p 80 -n 10000 -i eth2 -S "1.2.3.4-1.2.3.6" -G "05:0b:cf:c7:0d:a1" -o results</b></pre></div>
     
     <p class="front">If you are attempting to troubleshoot scan related issues, there are several options to help debug. First, it is possible can perform a <a href="#dryrun">dry run scan</a> in order to see the packets that would be sent over the network by specifying the <code>--dryrun=n</code> flag. As well, it is possible to change the <a href="#verbosity">logging verbosity</a> by setting the <code>--verbosity</code> flag.
    </p>   
       <p class="front">If you find yourself specifying certain settings, such as your default gateway, every time you run ZMap, you can set these in <code>/etc/zmap/zmap.conf</code>, <code>~/.zmap.conf</code>, or create a custom configuration file that contains any command-line option. For example, if you created a configuration file with the following options:</p>
     
     <div class="indent"><pre>interface "eth2"
source-ip 1.2.3.4-1.2.3.6
gateway-mac 05:0b:cf:c7:0d:a1 # upstream gateway</pre></div>
     
     <p class="front">then the same scan as above could be executed as follows:</p>
     <div class="indent"><pre><b>$ zmap -C zmap.conf -B 10M -p 80 -n 10000 -o results</b></pre></div>
     
     
     
					</div>
				</div>
				<div class="row-fluid"> 
					<div class="span10 white-panel offset1 nontitle">
						<div class="hometitle">
						  <h3>Scanning Best Practices</h3>
              <p class="front">
                While ZMap is a powerful tool for researchers, please keep in mind that by running ZMap, you are potentially scanning the <b>ENTIRE</b> public IPv4 address space and some users may not appreciate your scanning. We offer these suggestions for other researchers conducting fast Internet-wide scans as guidelines for good Internet citizenship.</p>
                <ol class="recommendations">
                  <li class="">Coordinate closely with local network admins to
                  reduce risks and handle inquiries</li>
                  <li class="">Verify that scans will not overwhelm the local network or upstream provider</li>
                  <li class="">Signal the benign nature of the scans in web pages
                  and DNS entries of the source addresses</li>
                  <li class="">Clearly explain the purpose and scope of the scans
                  in all communications</li>
                  <li class="">Provide a simple means of opting out, and honor
                  requests promptly</li>
                  <li class="">Conduct scans no larger or more frequent than is
                  necessary for research objectives</li>
                  <li class="">Spread scan traffic over time or source addresses
                  when feasible</li>
                </ol>
                <p class="front">It should go without saying that scan
                researchers should refrain from exploiting vulnerabilities or accessing protected resources, and should comply
                with any special legal requirements in their jurisdictions.</p>
					</div>
				</div>
				<div class="row-fluid"> 
					<div class="span10 white-panel offset1 nontitle">
						<div class="content">
						  <h3>Command Line Documentation</h3>
              <p> For all types of scans, ZMap requires several parameters: source ip address and gateway MAC address. ZMap supports sending packets from multiple source IP addresses and in the case of TCP SYN scans, from multiple ports. Because ZMap utilizes a raw socket to send network packets and <b>libpcap</b> to collect responses, ZMap must be run as root or with <b>cap_net_raw</b> (recommended). In the case that you want packets sent through a non-default interface, this can be be set by providing the <strong>interface</strong> argument.</p> <p> Basic arguments:</p>
							
							<dl class="dl-horizontal params">
								<dt>-S, --source-ip=ip|range</dt><dd>Source address(es) for scan packets (e.g. <b>1.1.1.3-1.1.1.8</b>)</dd>
							  	<dt>-G, --gateway-mac=addr</dt><dd>Specify gateway MAC address (e.g. <b>b4:23:f9:28:fa:2d</b>)</dd>
								<dt>-I, --interface=name</dt><dd>Specify network interface to use (e.g. <b>eth1</b>)</dd>
							</dl>
							
							<p><span class="label label-info">Heads Up!</span> One of the reasons that ZMap supports sending packets from multiple addresses and source ports is because this allows the scanner to embed small amounts of packet checksum data in these fields. This functionality helps the scanner separate legitimate responses from extraneous responses that may be received during scan runtime.</p>	
																
							<br/><h4>TCP SYN Scans</h4>
							<p>When performing a TCP SYN scan, ZMap requires a single target port and supports specifying a range of source ports from which the scan will originate.</p>
							<dl class="dl-horizontal params">
								<dt>-t, --target-port=port</dt><dd>TCP port number to scan (e.g. <b>443</b>)</dd>
								<dt>-P, --source-port=port|range</dt><dd>Source port(s) for scan packets (e.g. <strong>40000-50000</strong>)</dd>
							</dl>
							<p>For example, if you wanted to scan the Internet on port 443, from interface <b>eth1</b> at the rate of 1,000,000 hosts per second and saving the IP addresses that responded with synack packets, this could be accomplished with a command similar to the following:</p>
							<pre>zmap -t 443 -G 'b4:23:f9:28:fa:2d' -I eth1 -S 1.1.1.4 -r 10000000 -o results.csv</pre><br/>

							<p><span class="label label-warning">Warning!</span> ZMap relies on the Linux kernel to respond to SYN/ACK packets with RST packets in order to close connections opened by the scanner. This occurs because ZMap sends packets at the ethernet layer in order to reduce overhead otherwise incurred in the kernel from tracking open TCP connections and performing route lookups. As such, if you have a firewall rule that tracks established connections such as a netfilter rule similar to <code>-A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT</code>, this will block SYN/ACK packets from reaching the kernel. This will not prevent ZMap from recording responses, but it will prevent RST packets from being sent back, ultimately using up a connection on the scanned host until your connection times out. We strongly recommend that you select a set of unused ports on your scanning host which can be allowed access in your firewall and specifying this port range when executing ZMap, similar to the following:</p>
							<pre>zmap -t 443 -G 'b4:23:f9:28:fa:2d' -I eth1 -S 1.1.1.4 -r 10000000 -P '50000-60000'</pre>
							<br/>
							
							<h4>ICMP Echo Request Scans</h4>
							<p>While ZMap performs TCP SYN scans by default, it also supports ICMP echo request scans in which an ICMP echo request packet is sent to each host and the type of ICMP response received in reply is denoted. An ICMP scan can be performed by selecting the <strong>icmp_echoscan</strong> scan module similar to the following:</p>
							<pre>zmap -t 443 -G 'b4:23:f9:28:fa:2d' -S 1.1.1.4 --scan-type=icmp_echoscan -r 10000000</pre>
							<br/>
							<h4>Configuration Files</h4>
							<p>ZMap supports configuration files instead of requiring all options to be specified on the command-line. A configuration can be created by specifying one long-name option and the value per line such as:</p>
							<pre>
interface "eth1"
source-ip 1.1.1.4-1.1.1.8
gateway-mac b4:23:f9:28:fa:2d # upstream gateway
cooldown-time 300 # seconds
quiet
summary
</pre><br/>
<p>ZMap can then be run with a configuration file and specifying any additional necessary parameters:</p>
<pre>zmap --config=~/.zmap.conf --target-port=443 </pre>
							<br/>
							<h4>Verbosity</h4>
							<p>There are several types of on-screen output that ZMap produces. By default, ZMap will print out basic progress information similar to the following every 1 second. This can be disabled by setting the <strong>quiet</strong> flag.</p>
							<pre>
send: 74983 74949 p/s (74917 p/s avg); recv: 2150 2150 p/s (2148 p/s avg); hits: 0.29%</pre>
<br/>
<p>ZMap also prints out informational messages during scanner configuration such as the following, which can be controlled with the <strong>verbosity</strong> argument.</p>
<pre>
Jan 29 00:46:17.114 [INFO] zmap: reading configuration from `../conf/basic.conf'
Jan 29 00:46:17.116 [INFO] blacklist: '0.0.0.0/8'
Jan 29 00:46:17.116 [INFO] blacklist: '10.0.0.0/8'
Jan 29 00:46:17.116 [INFO] blacklist: '192.168.0.0/16'
Jan 29 00:46:17.119 [INFO] scan: will send from 2 addresses (1.1.1.1 - 1.1.1.4)

</pre>
<br/>
<p>ZMap also supports printing out a grep-able summary at the end of the scan, similar to below, which can be invoked with the <strong>summary</strong> flag.</p>
<pre>
cnf	target-port				443
cnf	source-port-range-begin			32768
cnf	source-port-range-end			61000
cnf	source-addr-range-begin			1.1.1.4
cnf	source-addr-range-end			1.1.1.8
cnf	maximum-packets				4294967295
cnf	maximum-runtime				0
cnf	permutation-seed			0
cnf	cooldown-period				300
cnf	send-interface				eth1
cnf	rate					45000
env	nprocessors				16
exc	send-start-time				Fri Jan 18 01:47:35 2013
exc	send-end-time				Sat Jan 19 00:47:07 2013
exc	recv-start-time				Fri Jan 18 01:47:35 2013
exc	recv-end-time				Sat Jan 19 00:52:07 2013
exc	sent					3722335150
exc	blacklisted				572632145
exc	first-scanned				1318129262
exc	hit-rate				0.874102
exc	synack-received-unique			32537000
exc	synack-received-total			36689941
exc	synack-cooldown-received-unique		193
exc	synack-cooldown-received-total		1543
exc	rst-received-unique			141901021
exc	rst-received-total			166779002
adv	source-port-secret			37952
adv	permutation-gen				4215763218
</pre>
<br/>
<p>Verbosity Arguments:</p>
<dl class="dl-horizontal params">
	<dt>-q, --quiet</dt><dd>Do not print update regular status updates</dd>
	<dt>-g, --summary</dt><dd>Provide a greppable summary at the end of the scan</dd>
	<dt>-v, --verbosity=n</dt><dd>Level of output detail</dd>
	<dt>-h, --help</dt><dd>Print help and exit</dd>
	<dt>-V, --version</dt><dd>Print version and exit</dd>
</dl>
<br/>
							<h4>Dry-Run Mode</h4>
							<p>Dry-run mode allows you test your configuration and find what packets will be sent without creating any traffic.</p> <dl class="dl-horizontal params">
								<dt>-d, --dryrun</dt><dd>Don't send actual packets</dd>
							</dl>
							
							<p>Instead of sending any traffic, ZMap will produce an output similar to the following:</p>
											
<pre>tcp { source: 46870 | dest: 443 | seq: 15587922 | checksum: 2520973312 }
ip { saddr: 1.1.1.4 | daddr: 98.28.28.36 | checksum: 910295040 }
eth { shost: 00:8b:24:d4:5b:f3 | dhost: b4:23:f9:28:fa:2d }
---------------------------------------------------------------------------------
tcp { source: 52413 | dest: 443 | seq: 15587922 | checksum: 1787953152 }
ip { saddr: 1.1.1.4 | daddr: 114.144.33.186 | checksum: 540540928 }
eth { shost: 00:8b:24:d4:5b:f3 | dhost: b4:23:f9:28:fa:2d }
---------------------------------------------------------------------------------
tcp { source: 38524 | dest: 443 | seq: 15587922 | checksum: 3076063232 }
ip { saddr: 1.1.1.4 | daddr: 177.175.204.20 | checksum: 918421504 }
eth { shost: 00:8b:24:d4:5b:f3 | dhost: b4:23:f9:28:fa:2d }</pre><br/>

							<a name="output"></a> 
							<h3>Results Output</h3>
								<p>ZMap can produce results in several formats through the use of output modules. ZMap currently supports three output formats: <strong>simple-file</strong>, <strong>extended-file</strong>, and <strong>redis</strong>. By default, ZMap will return results in the simple-file format and if no output file is specified, ZMap will not produce specific results. See <a href="#extension">Extending ZMap</a> for informationals.</p>
								
								<dl class="dl-horizontal params">
									<dt>-o, --output-file=p</dt><dd>File to write list of live IPs to</dd>
								  <dt>-M, --output-module=p</dt><dd>Invoke a custom output module</dd>
									<dt>-L, --list-output-modules</dt><dd>Lists installed output modules</dd>
								</dl><br/>
								
								<h4>Simple File</h4>
								<p>The simple file module will produce an output file containing only the unique IP addresses that responded successfully (e.g. SYNACK packet for TCP SYN scan). Example:
<pre>115.237.116.119
23.9.117.80
207.118.204.141
217.120.143.111
50.195.22.82
31.6.64.244
145.216.89.22
68.171.59.173</pre>						<br/>
								<h4>Extended File</h4>
								<p>The extended file module will produce a detailed record of all responses received from the scan:</p>
<pre>type,	saddr,		daddr,	 sport, dport, cooldown, rpt,	timestamp
synack,	12.32.45.67,	1.1.1.3, 443,	55834, 0,	 0, 	2013-01-25 14:58:43.833
rst,	119.220.213.46,	1.1.1.2, 443,	38424, 0,	 0,	2013-01-25 14:58:43.845
rst, 	119.220.213.46,	1.1.1.2, 443,	38424, 0,	 1,	2013-01-25 14:58:43.849
rst, 	189.64.129.255,	1.1.1.3, 443,	39083, 0,	 1,	2013-01-25 14:58:49.381
synack,	117.197.21.208,	1.1.1.2, 443,	44826, 0,	 1,	2013-01-25 14:58:49.381
rst, 	209.145.67.159,	1.1.1.3, 443,	56190, 0,	 1,	2013-01-25 14:58:49.386
rst, 	14.234.179.115,	1.1.1.3, 443, 	50203, 0,	 1,	2013-01-25 14:58:49.386</pre><br/>
								<h4>Redis</h4>
<p>The redis output module allows addresses to be added to a Redis queue instead of being saved to file which ultimately allows ZMap to be incorporated with post processing tools.</p
  
  <p> <span class="label label-info">Heads Up!</span> ZMap does not build with Redis support by default. If you are building ZMap from source, you can build with Redis support by running <code>make REDIS=true</code>.</p>
														<br/>

							<a name="address"></a> 
							<h3>Scan Order and Address Selection</h3>
							
							<p>IP addresses are scanned in a random permutation that is generated at the beginning of each scan. If you want to scan addresses in the same order over multiple scans or to scan the same subset of the IPv4 address space (see <a href="#sampling">sampling</a>), you can specify the permutation by specifying the seed option. It is not possible to specify the exact order in which addresses are scanned.</p>

							<dl class="dl-horizontal params">
							  <dt>-s, --seed=n</dt><dd>Set seed for selecting address permutation</dd>
							</dl>
							<br/>
							<a name="blacklisting"></a> 
							<h3>Blacklisting and Whitelisting</h3>
							<p>ZMap supports both blacklisting and whitelisting network prefixes. If ZMap is not provided with blacklist or whitelist parameters, ZMap will scan all IPv4 address (including local, reserved, and multicast addresses). If a blacklist file is specified, network prefixes in the blacklisted segments will not be scanned; if a whitelist file is provided, only network prefixes in the whitelist file will be scanned. A whitelist and blacklist file can be used in coordination. Whitelist and blacklist files can be specified on the command-line as follows:</p>

<dl class="dl-horizontal params">
  <dt>-b, --blacklist-file=path</dt><dd>File of subnets to blacklist in CIDR notation, e.g. 192.168.0.0/16</dd>
	<dt>-w, --whitelist-file=path</dt><dd>File of subnets to limit scan to in CIDR notation, e.g. 192.168.0.0/16</dd>
</dl>
	
<p>Blacklist files should be formatted with a single network prefix in <a href="http://en.wikipedia.org/wiki/CIDR_notation">CIDR notation</a> per line. Comments are allowed using the <code>#</code> character. Example:</p>
						
<pre>
0.0.0.0/8           # reserved
10.0.0.0/8          # RFC 1918
192.168.0.0/16      # RFC 1918
172.16.0.0/12       # RFC 1918
224.0.0.0/3         # multicast/future use
169.254.0.0/16      # link local addresses</pre><br/>
							<p><span class="label label-info">Heads Up!</span> If you are looking to scan only a random portion of the internet, checkout <a href="#sampling">Sampling</a>, instead of using whitelisting and blacklisting.</p>	
							<br/>

							<a name="ratelimiting"></a> 
							<h3>Rate Limiting and Sampling</h3>
							<p>By default, ZMap will scan at the fastest rate that your network adaptor supports. In our experiences on commodity hardware, this is generally around 95-98% of the theoretical speed of gigabit ethernet, which may be faster than your upstream provider can handle. ZMap will not automatically adjust its send-rate based on your upstream provider and the send-rate may need to be manually adjusted to find the fastest you can scan without experiencing significant packet drop.</p>
							<dl class="dl-horizontal params">
								<dt>-r, --rate=pps</dt><dd>Set maximum send rate in packets/sec</dd>
							</dl>

							<p>ZMap also allows random sampling of the IPv4 address space by specifying max-targets and/or max-runtime. Because hosts are scanned in a random permutation generated per scan instantiation, limiting a scan to <emph>n</emph> hosts will perform a random sampling of <emph>n</emph> hosts. Command-line options:</p>
							<dl class="dl-horizontal params">
							  <dt>-m, --max-targets=n</dt><dd>Cap number of targets to probe</dd>
							  <dt>-T, --max-runtime=s</dt><dd>Cap length of time for sending packets (in seconds)</dd>
							</dl>
							<p>For example, if you wanted to scan the same one million hosts on the Internet for multiple scans, you could set a predetermined seed and cap the number of scanned hosts similar to the following:</p>
							<pre>zmap -t 443 -G 'b4:23:f9:28:fa:2d' -I eth1 -S 1.1.1.4 -s 3 -m 10000000 -o results.csv</pre><br/>
							<p>In order to determine which one million hosts were going to be scanned, you could run the scan in dry-run mode which will print out the packets that would be sent instead of performing the actual scan.</p>
							<pre>zmap -t 443 -G 'b4:23:f9:28:fa:2d' -I eth1 -S 1.1.1.4 -s 3 -m 10000000 --dryrun</pre>
							<br/>
							<a name="multiple"></a> 
							<h3>Sending Multiple Packets</h3>
							<p>ZMap supports sending multiple packets to each host by setting </p>
			
							<dl class="dl-horizontal params">
							  <dt>-p, --ident-packets=n</dt><dd>The number of times each particular scan packet is sent</dd>
							</dl>
							<br/>
							
							<p><span class="label label-info">Heads Up!</span> Many routers on the Internet drop duplicated packets (such as those created by the <strong>ident-packets</strong>).</p>	
												<br/>	
							<a name="advanced"></a> 
							<h3>Advanced Options</h3>
							<h4>Scanner Cool-Down</h4>
							<p> Because the sending and receiving components of ZMap operate independently, each can run for different lengths of time. We generally recommend that receiving component continue running approximately 30 seconds after the finish of the sending thread in order to receive any slow responses. This can be set to a different value via the <strong>cooldown-time</strong> parameter</p>
							<dl class="dl-horizontal params">
								<dt>-c, --cooldown-time=secs</dt><dd>How long to wait after the last packet is sent before terminating receiver</dd>
							</dl>
							<br/>
							<h4>Threading</h4>
							<p>ZMap always operates the sending and receiving components in separate threads. However, ZMap also supports sending from multiple threads which can greatly improve performance. The <strong>sender-threads</strong> parameter determines the number of threads that ZMap will utilize to send packets. It generally does not increase performance to have a larger number than sending threads than the number of available CPUs in the scanning host.</p>
							<dl class="dl-horizontal params">
								<dt>-n, --sender-threads</dt><dd>Threads used to send packets (default=`1')</dd>
							</dl><br/>
					</div>
				</div>
				
				
				
				
				<div class="row-fluid"> 
					<div class="span10 white-panel offset1 nontitle">
						<div class="content">
						  <h3>Sample ZMap Applications</h3>
						  <p>We have included several sample applications with ZMap</p>
             
					</div>
				</div>
				
								<div class="row-fluid"> 
        					<div class="span10 white-panel offset1 nontitle">
        						<div class="content">
        						  <h3>Extending ZMap</h3>
        							<p>ZMap can be extended to support different types of scanning through <strong>probe modules</strong> and additional types of results output through <strong>output modules</strong>. Registered probe and output modules can be listed through the command-line interface:</p>
        							<dl class="dl-horizontal params">
        								<dt>-L, --list-output-modules</dt><dd>Lists installed output modules</dd>
        								<dt>-l, --list-scan-types</dt><dd>Lists available scan types</dd>
        							</dl><br/>
                      <h4>Output Modules</h4>
        							<p>ZMap output and post-processing can be extended by implementing and registering <strong>output modules</strong> with the scanner. Output modules receive a callback for every received response packet. While the default provided modules provide simple output, these modules are also capable of performing additional post-processing (e.g. keeping track of duplicates or outputting numbers in terms of AS instead of IP address)</p><br/>

        <p>Output modules are created by defining a new output_module struct and registering it in <a href="#">output_modules.c</a>:</p>

        <pre>struct output_module {

            const char *name; <em>// how is output module referenced in the CLI</em>
            unsigned update_interval; <em>// how often is update called in seconds</em>

            setup_cb init;  <em>// called at scanner initialization</em>
            update_cb start; <em>// called at the beginning of scanner</em>
            update_cb update; <em>// called every update_interval seconds</em>
            update_cb close; <em>// called at scanner termination</em>

            send_cb synsend; <em>// called when a probe packet is sent</em>
            pckt_cb success_ip; <em>// called when a successful response is received</em>
            pckt_cb other_ip; <em>// called when any other responses are received</em>

        } output_module_t;</pre><br/>

        <p>Output modules must have a name which is how they are referenced on the command-line and generally implement <code>success_ip</code> and oftentimes <code>other_ip</code> callback. The success_ip callback is called for every response packet that is received and is classified as a success (e.g. TCP SYN/ACK or ICMP echo response) by the current <strong>send module</strong>. The <code>other_ip</code> callback is called whenever a non-successful, but valid response (e.g. TCP RST or ICMP route unreachable) is received. These callbacks must define functions that match the <code>pckt_cb</code> definition:</p>

        <pre>
        int (*pckt_cb) (

            ipaddr_n_t saddr, <em>// IP address of scanned host in network-order</em>
            ipaddr_n_t daddr, <em>// destination IP address in network-order </em>

            port_n_t sport, <em>// port of scanned host in network-order</em>
            port_n_t dport, <em>// destination port in network-order</em>

            struct timeval* recv_at, <em>// timeval of when response was received</em>
            const char* response_type, <em>// send-module classification of packet</em>

            int is_repeat, <em>// {0: first response from host, 1: subsequent responses}</em>
            int in_cooldown, <em>// {0: not in cooldown state, 1: scanner in cooldown state}</em>

            const u_char* packet, <em>// pointer to raw packet struct</em>
            size_t packet_len <em>// length of raw packet</em>

        );
        </pre><br/>

        <p>An output module can also register callbacks to be executed at scanner initialization (tasks such as opening an output file), start of the scan (such as documenting blacklisted addresses), during regular intervals during the scan (tasks such as progress updates), and close (tasks such as closing any open file descriptors). These callbacks are provided with complete access to the scan configuration and current state:</p>
        <pre>int (*update_cb)(struct state_conf*, struct state_send*, struct state_recv*);</pre>
        <p>which are defined in <a href="#">state.h</a>. An example is available at <a href="#">src/output_modules/module_extended_file.c</a>.</p>
        <br/>

        <h4>Probe Modules</h4>
        <p>Packets are constructed using <strong>send modules</strong> which allow abstracted packet creation and response classification. Each type of scan (e.g. TCP SYN scan or ICMP echo request scan) is implemented by developing and registering the necessary callbacks in a <code>send_module_t</code> struct:</p>

        <pre>
        typedef struct send_module {

          const char *name; <em>// how scan is invoked on command-line</em>
          size_t packet_length; <em>// how long is probe packet (must be static size)</em>

          const char *pcap_filter; <em>// PCAP filter for collecting responses</em>
          size_t pcap_snaplen; <em>// maximum number of bytes for libpcap to capture</em>

          uint8_t check_src_port; <em>// validate the source port the response is sent from</em>
          uint8_t check_tcp_seqnum; <em>// validate TCP ack matches random probe seqnum</em>
          uint8_t check_icmp_seqnum; <em>// validate ICMP seqnum matches probe seqnum</em>
          uint8_t check_dst_port;

          setup_cb global_initialize; <em>// called once at scanner initialization</em>
          send_init_cb thread_initialize; <em>// called once for each thread packet buffer</em>
          make_packet_cb make_packet; <em>// called once per host to update packet</em>

          print_packet_cb print_packet; <em>// called per packet if in dry-run mode</em>
          classify_packet_cb classify_packet; <em>// called by receiver to classify response</em>
          update_cb close; <em>// called at scanner termination</em>

          response_type_t responses[]; <em>// possible response classifications</em>

        } send_module_t;
        </pre>


        <pre>
        struct send_module {
          const char *name; 
          size_t packet_length; 
          const char *pcap_filter; 


        } send_module_t;
        </pre>
        <br/><p>At scanner initialization, <code>global_initialize</code> is called once and can be utilized to perform any necessary global configuration or initialization. However, <code>global_initialize</code> does not have access to the packet buffer which is thread-specific. Instead, <code>thread_initialize</code> is called at the initialization of each sender thread and is provided with access to the buffer that will be used for constructing probe packets along with global source and destination values. This callback should be used to construct the host agonistic packet structure such that only specific values (e.g. destination host and checksum) need to be be updated for each host. For example, the ethernet header will not change between headers (minus checksum which is calculated in hardware by the NIC) and therefore can be defined ahead of time in order to reduce overhead at scan time.</p>

        <p>The <code>make_packet</code> callback is called for each host that is scanned to allow the <strong>scan module</strong> to update host specific values and is provided with port and IP address values (shown below). The send module must utilize these values instead of assigning their own or response packets if they utilize scanner response verification.</p>
        <pre>int make_packet(

          void *buf, <em>// packet buffer</em>

          ipaddr_n_t src_ip, <em>// source IP in network-order</em>
          port_n_t src_port, <em>// source port in network-order</em>

          ipaddr_n_t dst_ip, <em>// destination IP in network-order</em>
          port_n_t dst_port, <em>// destination port in network-order</em>

          uint32_t tcp_seqnum, <em>// tcp sequence number</em>
          uint16_t icmp_id <em>// ICMP id number</em>

        );</pre><br/>

        <p>Scan modules must also define <code>pcap_filter</code> and <code>classify_packet</code>. Only packets that match the PCAP filter will be considered by the scanner. For example, in the case of a TCP SYN scan, we only want to investigate TCP SYN/ACK or TCP RST packets and would utilize a filter similar to <code>tcp && tcp[13] & 4 != 0 || tcp[13] == 18</code>. The <code>classify_packet</code> function will be called for every packet that fulfills this PCAP filter and passes basic ZMap validation.  As part of writing the send module, you will need to register possible responses, similar to the following:</p>

        <pre>static response_type_t responses[] = {
        	{
        		.is_success = 1,	
        		.name = "synack"
        	},
        	{
        		.is_success = 0,
        		.name = "rst"
        	}
        };
        </pre><br/><p>The classify function should accept a packet buffer and return a const response_type_t pointer to one of these responses upon receiving the packet. This classification will later be used as part of determining the scan output.</p>
        					</div>
        				</div>

				</div>  
			</div>
			</div>
		</div>
	</body>
</html>